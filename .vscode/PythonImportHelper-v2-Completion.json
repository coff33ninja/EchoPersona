[
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "logging.config",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging.config",
        "description": "logging.config",
        "detail": "logging.config",
        "documentation": {}
    },
    {
        "label": "tkinter",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter",
        "description": "tkinter",
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "ttk",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "messagebox",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "ttk",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "messagebox",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "filedialog",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "messagebox",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "simpledialog",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "ttk",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "AudioSegment",
        "importPath": "pydub",
        "description": "pydub",
        "isExtraImport": true,
        "detail": "pydub",
        "documentation": {}
    },
    {
        "label": "AudioSegment",
        "importPath": "pydub",
        "description": "pydub",
        "isExtraImport": true,
        "detail": "pydub",
        "documentation": {}
    },
    {
        "label": "AudioSegment",
        "importPath": "pydub",
        "description": "pydub",
        "isExtraImport": true,
        "detail": "pydub",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "unicodedata",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unicodedata",
        "description": "unicodedata",
        "detail": "unicodedata",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "queue",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "queue",
        "description": "queue",
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "playsound",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "playsound",
        "description": "playsound",
        "detail": "playsound",
        "documentation": {}
    },
    {
        "label": "TTS",
        "importPath": "tts.api",
        "description": "tts.api",
        "isExtraImport": true,
        "detail": "tts.api",
        "documentation": {}
    },
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "TTS",
        "importPath": "TTS.api",
        "description": "TTS.api",
        "isExtraImport": true,
        "detail": "TTS.api",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "VoiceTrainer",
        "importPath": "voice_tools",
        "description": "voice_tools",
        "isExtraImport": true,
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "soundfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "soundfile",
        "description": "soundfile",
        "detail": "soundfile",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "Trainer",
        "importPath": "trainer",
        "description": "trainer",
        "isExtraImport": true,
        "detail": "trainer",
        "documentation": {}
    },
    {
        "label": "TrainerArgs",
        "importPath": "trainer",
        "description": "trainer",
        "isExtraImport": true,
        "detail": "trainer",
        "documentation": {}
    },
    {
        "label": "BaseAudioConfig",
        "importPath": "TTS.config",
        "description": "TTS.config",
        "isExtraImport": true,
        "detail": "TTS.config",
        "documentation": {}
    },
    {
        "label": "BaseDatasetConfig",
        "importPath": "TTS.config",
        "description": "TTS.config",
        "isExtraImport": true,
        "detail": "TTS.config",
        "documentation": {}
    },
    {
        "label": "VitsConfig",
        "importPath": "TTS.tts.configs.vits_config",
        "description": "TTS.tts.configs.vits_config",
        "isExtraImport": true,
        "detail": "TTS.tts.configs.vits_config",
        "documentation": {}
    },
    {
        "label": "load_tts_samples",
        "importPath": "TTS.tts.datasets",
        "description": "TTS.tts.datasets",
        "isExtraImport": true,
        "detail": "TTS.tts.datasets",
        "documentation": {}
    },
    {
        "label": "Vits",
        "importPath": "TTS.tts.models.vits",
        "description": "TTS.tts.models.vits",
        "isExtraImport": true,
        "detail": "TTS.tts.models.vits",
        "documentation": {}
    },
    {
        "label": "AudioProcessor",
        "importPath": "TTS.utils.audio",
        "description": "TTS.utils.audio",
        "isExtraImport": true,
        "detail": "TTS.utils.audio",
        "documentation": {}
    },
    {
        "label": "TTSTokenizer",
        "importPath": "TTS.tts.utils.text.tokenizer",
        "description": "TTS.tts.utils.text.tokenizer",
        "isExtraImport": true,
        "detail": "TTS.tts.utils.text.tokenizer",
        "documentation": {}
    },
    {
        "label": "BaseCharacters",
        "importPath": "TTS.tts.utils.text.characters",
        "description": "TTS.tts.utils.text.characters",
        "isExtraImport": true,
        "detail": "TTS.tts.utils.text.characters",
        "documentation": {}
    },
    {
        "label": "speech_recognition",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "speech_recognition",
        "description": "speech_recognition",
        "detail": "speech_recognition",
        "documentation": {}
    },
    {
        "label": "pyttsx3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyttsx3",
        "description": "pyttsx3",
        "detail": "pyttsx3",
        "documentation": {}
    },
    {
        "label": "sounddevice",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sounddevice",
        "description": "sounddevice",
        "detail": "sounddevice",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "write",
        "importPath": "scipy.io.wavfile",
        "description": "scipy.io.wavfile",
        "isExtraImport": true,
        "detail": "scipy.io.wavfile",
        "documentation": {}
    },
    {
        "label": "read",
        "importPath": "scipy.io.wavfile",
        "description": "scipy.io.wavfile",
        "isExtraImport": true,
        "detail": "scipy.io.wavfile",
        "documentation": {}
    },
    {
        "label": "gTTS",
        "importPath": "gtts",
        "description": "gtts",
        "isExtraImport": true,
        "detail": "gtts",
        "documentation": {}
    },
    {
        "label": "play",
        "importPath": "pydub.playback",
        "description": "pydub.playback",
        "isExtraImport": true,
        "detail": "pydub.playback",
        "documentation": {}
    },
    {
        "label": "speedup",
        "importPath": "pydub.effects",
        "description": "pydub.effects",
        "isExtraImport": true,
        "detail": "pydub.effects",
        "documentation": {}
    },
    {
        "label": "simpleaudio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "simpleaudio",
        "description": "simpleaudio",
        "detail": "simpleaudio",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "librosa",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "librosa",
        "description": "librosa",
        "detail": "librosa",
        "documentation": {}
    },
    {
        "label": "noisereduce",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "noisereduce",
        "description": "noisereduce",
        "detail": "noisereduce",
        "documentation": {}
    },
    {
        "label": "Scale",
        "importPath": "tkinter.ttk",
        "description": "tkinter.ttk",
        "isExtraImport": true,
        "detail": "tkinter.ttk",
        "documentation": {}
    },
    {
        "label": "RetryFileHandler",
        "kind": 6,
        "importPath": "enhanced_logger",
        "description": "enhanced_logger",
        "peekOfCode": "class RetryFileHandler(logging.FileHandler):\n    def __init__(\n        self, filename, mode=\"a\", encoding=None, delay=False, retries=5, delay_s=1\n    ):\n        self.retries = retries\n        self.delay_s = delay_s\n        super().__init__(filename, mode, encoding, delay)\n    def _open(self):\n        for attempt in range(self.retries):\n            try:",
        "detail": "enhanced_logger",
        "documentation": {}
    },
    {
        "label": "setup_logger",
        "kind": 2,
        "importPath": "enhanced_logger",
        "description": "enhanced_logger",
        "peekOfCode": "def setup_logger(log_file_path=\"app.log\", level=logging.INFO):\n    \"\"\"\n    Configures the logging system.\n    Args:\n        log_file_path (str): The full path for the log file.\n        level (int): The logging level (e.g., logging.INFO, logging.DEBUG).\n    \"\"\"\n    # Ensure UTF-8 console encoding on Windows\n    if sys.platform.startswith(\"win\"):\n        try:",
        "detail": "enhanced_logger",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "kind": 2,
        "importPath": "enhanced_logger",
        "description": "enhanced_logger",
        "peekOfCode": "def get_logger(name):\n    \"\"\"\n    Retrieves a logger instance. Call setup_logger first.\n    Args:\n        name (str): The name for the logger (usually __name__).\n    Returns:\n        logging.Logger: The logger instance.\n    \"\"\"\n    return logging.getLogger(name)\n# Example usage",
        "detail": "enhanced_logger",
        "documentation": {}
    },
    {
        "label": "LOGGING_CONFIG",
        "kind": 5,
        "importPath": "enhanced_logger",
        "description": "enhanced_logger",
        "peekOfCode": "LOGGING_CONFIG = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"formatters\": {\n        \"standard\": {\n            \"format\": \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n            \"datefmt\": \"%Y-%m-%d %H:%M:%S\",\n        },\n    },\n    \"handlers\": {",
        "detail": "enhanced_logger",
        "documentation": {}
    },
    {
        "label": "segment_audio_file",
        "kind": 2,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "def segment_audio_file(audio_path, output_dir, onset=0.6, offset=0.4, min_duration=2.0, min_duration_off=0.0, hf_token=\"\"):\n    \"\"\"Segment audio using PyAnnote's segmentation model.\"\"\"\n    if not hf_token:\n        logging.warning(\"No Hugging Face token provided. Skipping segmentation.\")\n        return []\n    try:\n        from pyannote.audio import Pipeline\n        pipeline = Pipeline.from_pretrained(\"pyannote/segmentation\", use_auth_token=hf_token)\n        segments = pipeline(audio_path)\n        audio = AudioSegment.from_file(audio_path)",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "clean_transcript",
        "kind": 2,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "def clean_transcript(text, strict_ascii=False):\n    \"\"\"Clean transcription text, supporting Unicode or strict ASCII.\"\"\"\n    if not text:\n        return \"\"\n    text = unicodedata.normalize(\"NFKC\", text)\n    text = text.replace(\"|\", \" \").strip()\n    if strict_ascii:\n        text = text.encode(\"ascii\", errors=\"ignore\").decode(\"ascii\")\n    return text\ndef is_valid_for_phonemes(text):",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "is_valid_for_phonemes",
        "kind": 2,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "def is_valid_for_phonemes(text):\n    \"\"\"Check if text contains characters likely to cause phoneme errors.\"\"\"\n    problematic = any(ord(c) > 127 and unicodedata.category(c).startswith(\"S\") for c in text)\n    return not problematic\ndef split_metadata(metadata_path, valid_ratio=0.2):\n    \"\"\"Split metadata into train and valid sets.\"\"\"\n    try:\n        df = pd.read_csv(metadata_path, sep=\"|\", encoding=\"utf-8\")\n        n_valid = int(len(df) * valid_ratio)\n        indices = np.random.permutation(len(df))",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "split_metadata",
        "kind": 2,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "def split_metadata(metadata_path, valid_ratio=0.2):\n    \"\"\"Split metadata into train and valid sets.\"\"\"\n    try:\n        df = pd.read_csv(metadata_path, sep=\"|\", encoding=\"utf-8\")\n        n_valid = int(len(df) * valid_ratio)\n        indices = np.random.permutation(len(df))\n        train_df = df.iloc[indices[n_valid:]]\n        valid_df = df.iloc[indices[:n_valid]]\n        train_path = metadata_path\n        valid_path = os.path.join(os.path.dirname(metadata_path), \"valid.csv\")",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "get_category_files",
        "kind": 2,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "def get_category_files(category):\n    \"\"\"Fetches file titles from a Wiki category.\"\"\"\n    params = {\n        \"action\": \"query\",\n        \"list\": \"categorymembers\",\n        \"cmtype\": \"file\",\n        \"cmtitle\": category,\n        \"cmlimit\": 500,\n        \"format\": \"json\",\n    }",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "get_file_url",
        "kind": 2,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "def get_file_url(file_title):\n    \"\"\"Fetches the direct URL for a Wiki file.\"\"\"\n    params = {\n        \"action\": \"query\",\n        \"titles\": file_title,\n        \"prop\": \"imageinfo\",\n        \"iiprop\": \"url\",\n        \"format\": \"json\",\n    }\n    try:",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "download_and_convert",
        "kind": 2,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "def download_and_convert(file_url, output_dir, file_name, status_label=None):\n    \"\"\"Downloads OGG and converts to WAV.\"\"\"\n    safe_file_name = re.sub(r'[\\\\/*?:\"<>|]', \"_\", file_name)\n    ogg_file_name = safe_file_name if safe_file_name.lower().endswith(\".ogg\") else f\"{safe_file_name}.ogg\"\n    wav_file_name = ogg_file_name.replace(\".ogg\", \".wav\").replace(\".OGG\", \".wav\")\n    ogg_path = os.path.join(output_dir, ogg_file_name)\n    wav_path = os.path.join(output_dir, wav_file_name)\n    if os.path.exists(wav_path):\n        logging.info(f\"Skipping existing WAV: {wav_path}\")\n        if status_label:",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "fetch_character_list_from_api",
        "kind": 2,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "def fetch_character_list_from_api():\n    \"\"\"Fetches character names from jmp.blue API.\"\"\"\n    try:\n        response = requests.get(f\"{JMP_API_URL_BASE}/characters\", timeout=10)\n        response.raise_for_status()\n        character_slugs = response.json()\n        character_names = []\n        for slug in character_slugs:\n            try:\n                char_response = requests.get(f\"{JMP_API_URL_BASE}/characters/{slug}\", timeout=5)",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "transcribe_character_audio",
        "kind": 2,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "def transcribe_character_audio(character_output_dir, whisper_model=\"base\", use_segmentation=False, hf_token=\"\", strict_ascii=False, status_label=None):\n    \"\"\"Transcribes WAV files, with optional segmentation and Unicode support.\"\"\"\n    if SpeechToText is None:\n        logging.error(\"Transcription unavailable: SpeechToText not imported.\")\n        if status_label:\n            status_label.config(text=\"Transcription unavailable.\")\n        return\n    metadata_path = os.path.join(character_output_dir, \"metadata.csv\")\n    wavs_dir = os.path.join(character_output_dir, \"wavs\")\n    os.makedirs(wavs_dir, exist_ok=True)",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "validate_metadata_existence",
        "kind": 2,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "def validate_metadata_existence(character_output_dir):\n    \"\"\"Check if metadata.csv exists.\"\"\"\n    metadata_path = os.path.join(character_output_dir, \"metadata.csv\")\n    if not os.path.exists(metadata_path):\n        logging.warning(f\"Metadata file missing: {metadata_path}\")\n        return False\n    return True\ndef validate_metadata_layout(metadata_path):\n    \"\"\"Validate metadata.csv format.\"\"\"\n    try:",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "validate_metadata_layout",
        "kind": 2,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "def validate_metadata_layout(metadata_path):\n    \"\"\"Validate metadata.csv format.\"\"\"\n    try:\n        with open(metadata_path, \"r\", encoding=\"utf-8\") as f:\n            lines = f.readlines()\n        if len(lines) < 2:\n            logging.error(f\"Metadata file {metadata_path} is empty.\")\n            return False\n        header = lines[0].strip()\n        expected_headers = [",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "update_character_config",
        "kind": 2,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "def update_character_config(character, base_output_dir, selected_model=\"Fast Tacotron2\"):\n    \"\"\"Automatically updates the JSON configuration file for a character.\"\"\"\n    character_folder = os.path.join(base_output_dir, character)\n    wavs_folder = os.path.join(character_folder, \"wavs\")\n    metadata_path = os.path.join(character_folder, \"metadata.csv\")\n    valid_metadata_path = os.path.join(character_folder, \"valid.csv\")\n    config_path = os.path.join(character_folder, f\"{character}_config.json\")\n    config = {\n        \"output_path\": os.path.join(base_output_dir, \"tts_train_output\", character),\n        \"datasets\": [",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "generate_valid_csv",
        "kind": 2,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "def generate_valid_csv(metadata_path, valid_ratio=0.2):\n    \"\"\"Generate a valid.csv file from metadata.csv for validation purposes.\"\"\"\n    try:\n        df = pd.read_csv(metadata_path, sep=\"|\", encoding=\"utf-8\")\n        n_valid = int(len(df) * valid_ratio)\n        indices = np.random.permutation(len(df))\n        valid_df = df.iloc[indices[:n_valid]]\n        valid_path = os.path.join(os.path.dirname(metadata_path), \"valid.csv\")\n        valid_df.to_csv(valid_path, sep=\"|\", index=False, encoding=\"utf-8\")\n        logging.info(f\"Valid CSV generated: {valid_path}\")",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "process_character_voices",
        "kind": 2,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "def process_character_voices(\n    character, language, base_output_dir, download_wiki_audio=True, whisper_model=\"base\",\n    use_segmentation=False, hf_token=\"\", strict_ascii=False, status_label=None\n):\n    \"\"\"Downloads and processes voice lines.\"\"\"\n    safe_character_name = re.sub(r'[\\\\/*?:\"<>|]', \"_\", character)\n    character_folder = os.path.join(base_output_dir, safe_character_name)\n    wavs_folder = os.path.join(character_folder, \"wavs\")\n    os.makedirs(wavs_folder, exist_ok=True)\n    if not download_wiki_audio:",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "generate_character_config",
        "kind": 2,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "def generate_character_config(\n    character,\n    character_dir,\n    sample_rate,\n    selected_model=\"Fast Tacotron2\",\n    pre_trained_path=None,\n):\n    \"\"\"Generates a Coqui TTS config.json for a specific character.\"\"\"\n    if selected_model not in AVAILABLE_MODELS:\n        logging.error(f\"Invalid model selected: {selected_model}\")",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "start_tts_training",
        "kind": 2,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "def start_tts_training(config_path):\n    \"\"\"Starts Coqui TTS training using a generated config file.\"\"\"\n    try:\n        subprocess.run(\n            [\"tts\", \"--config_path\", config_path],\n            check=True,\n            text=True,\n            capture_output=True\n        )\n        logging.info(f\"Training started with config: {config_path}\")",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "backup_file",
        "kind": 2,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "def backup_file(file_path, suffix):\n    \"\"\"Create a backup of a file with a given suffix.\"\"\"\n    if os.path.exists(file_path):\n        backup_path = f\"{file_path}.{suffix}.{datetime.datetime.now().strftime('%Y%m%d%H%M%S')}\"\n        shutil.copy(file_path, backup_path)\n        logging.info(f\"Backup created: {backup_path}\")\n# --- GUI ---\nwindow = None\ndef main_gui():\n    global window",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "main_gui",
        "kind": 2,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "def main_gui():\n    global window\n    window = tk.Tk()\n    window.title(\"Genshin Impact Voice Downloader & Transcriber\")\n    # Configuration Frame\n    config_frame = ttk.LabelFrame(window, text=\"Configuration\")\n    config_frame.grid(row=0, column=0, padx=10, pady=10, sticky=\"ew\")\n    # Language Selection\n    ttk.Label(config_frame, text=\"Language:\").grid(row=0, column=0, padx=5, pady=5, sticky=\"w\")\n    languages = [\"English\", \"Japanese\", \"Chinese\", \"Korean\"]",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "BASE_DATA_DIR",
        "kind": 5,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "BASE_DATA_DIR = \"voice_datasets\"\nWIKI_API_URL = \"https://genshin-impact.fandom.com/api.php\"\nJMP_API_URL_BASE = \"https://genshin.jmp.blue\"\n# --- Helper Functions (Unchanged except for segment_audio_file) ---\ndef segment_audio_file(audio_path, output_dir, onset=0.6, offset=0.4, min_duration=2.0, min_duration_off=0.0, hf_token=\"\"):\n    \"\"\"Segment audio using PyAnnote's segmentation model.\"\"\"\n    if not hf_token:\n        logging.warning(\"No Hugging Face token provided. Skipping segmentation.\")\n        return []\n    try:",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "WIKI_API_URL",
        "kind": 5,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "WIKI_API_URL = \"https://genshin-impact.fandom.com/api.php\"\nJMP_API_URL_BASE = \"https://genshin.jmp.blue\"\n# --- Helper Functions (Unchanged except for segment_audio_file) ---\ndef segment_audio_file(audio_path, output_dir, onset=0.6, offset=0.4, min_duration=2.0, min_duration_off=0.0, hf_token=\"\"):\n    \"\"\"Segment audio using PyAnnote's segmentation model.\"\"\"\n    if not hf_token:\n        logging.warning(\"No Hugging Face token provided. Skipping segmentation.\")\n        return []\n    try:\n        from pyannote.audio import Pipeline",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "JMP_API_URL_BASE",
        "kind": 5,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "JMP_API_URL_BASE = \"https://genshin.jmp.blue\"\n# --- Helper Functions (Unchanged except for segment_audio_file) ---\ndef segment_audio_file(audio_path, output_dir, onset=0.6, offset=0.4, min_duration=2.0, min_duration_off=0.0, hf_token=\"\"):\n    \"\"\"Segment audio using PyAnnote's segmentation model.\"\"\"\n    if not hf_token:\n        logging.warning(\"No Hugging Face token provided. Skipping segmentation.\")\n        return []\n    try:\n        from pyannote.audio import Pipeline\n        pipeline = Pipeline.from_pretrained(\"pyannote/segmentation\", use_auth_token=hf_token)",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "AVAILABLE_MODELS",
        "kind": 5,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "AVAILABLE_MODELS = {\n    \"Fast Tacotron2\": {\n        \"model_id\": \"tts_models/en/ljspeech/tacotron2-DDC\",\n        \"use_pre_trained\": True,\n    },\n    \"High-Quality VITS\": {\n        \"model_id\": \"tts_models/multilingual/multi-dataset/vits\",\n        \"use_pre_trained\": False,\n    },\n}",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "window",
        "kind": 5,
        "importPath": "genshin_voice_downloader-old",
        "description": "genshin_voice_downloader-old",
        "peekOfCode": "window = None\ndef main_gui():\n    global window\n    window = tk.Tk()\n    window.title(\"Genshin Impact Voice Downloader & Transcriber\")\n    # Configuration Frame\n    config_frame = ttk.LabelFrame(window, text=\"Configuration\")\n    config_frame.grid(row=0, column=0, padx=10, pady=10, sticky=\"ew\")\n    # Language Selection\n    ttk.Label(config_frame, text=\"Language:\").grid(row=0, column=0, padx=5, pady=5, sticky=\"w\")",
        "detail": "genshin_voice_downloader-old",
        "documentation": {}
    },
    {
        "label": "ensure_tts_model",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def ensure_tts_model(model_id, status_queue=None):\n    \"\"\"\n    Checks if a TTS model is available locally and downloads it if missing.\n    Args:\n        model_id (str): The Coqui TTS model identifier (e.g., 'tts_models/en/ljspeech/tacotron2-DDC').\n        status_queue (queue.Queue, optional): Queue for GUI status updates.\n    Returns:\n        bool: True if the model is available or successfully downloaded, False otherwise.\n    \"\"\"\n    if TTS is None:",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "segment_audio_file",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def segment_audio_file(audio_path, output_dir, onset=0.6, offset=0.4, min_duration=2.0, hf_token=\"\"):\n    \"\"\"\n    Segments an audio file into smaller chunks based on voice activity detection using pyannote.audio.\n    Args:\n        audio_path (str): Path to the input audio file.\n        output_dir (str): Directory to save the segmented WAV files.\n        onset (float): Onset threshold for voice activity detection.\n        offset (float): Offset threshold for voice activity detection.\n        min_duration (float): Minimum duration (in seconds) for a segment to be kept.\n        hf_token (str): Hugging Face authentication token (required for pyannote).",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "clean_transcript",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def clean_transcript(text, strict_ascii=False):\n    \"\"\"\n    Cleans and normalizes a transcript text.\n    Args:\n        text (str): The input transcript text.\n        strict_ascii (bool): If True, remove non-ASCII characters.\n    Returns:\n        str: The cleaned transcript text.\n    \"\"\"\n    if not text:",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "is_valid_for_phonemes",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def is_valid_for_phonemes(text):\n    \"\"\"\n    Checks if the text contains characters problematic for phonemizers (e.g., standalone symbols).\n    Args:\n        text (str): The input text.\n    Returns:\n        bool: True if the text is likely valid, False otherwise.\n    \"\"\"\n    if not text: # Empty string is valid\n        return True",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "get_category_files",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def get_category_files(category):\n    \"\"\"\n    Fetches file titles from a specific category on the Genshin Impact Fandom Wiki.\n    Args:\n        category (str): The category title (e.g., \"Category:Arlecchino Voice-Overs\").\n    Returns:\n        list: A list of file titles (e.g., \"File:Vo arlecchino about us 01.ogg\") found in the category.\n              Filters out non-English voice lines based on common naming patterns.\n    \"\"\"\n    params = {",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "get_file_url",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def get_file_url(file_title):\n    \"\"\"\n    Gets the direct download URL for a file title from the Wiki.\n    Args:\n        file_title (str): The file title (e.g., \"File:Vo arlecchino about us 01.ogg\").\n    Returns:\n        str or None: The direct download URL if found, otherwise None.\n    \"\"\"\n    params = {\n        \"action\": \"query\",",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "download_and_convert",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def download_and_convert(file_url, output_dir, file_name, status_queue=None):\n    \"\"\"\n    Downloads an OGG file, converts it to WAV (22050 Hz, mono), and saves it.\n    Args:\n        file_url (str): The URL of the OGG file to download.\n        output_dir (str): The directory to save the final WAV file.\n        file_name (str): The base name for the file (will be sanitized).\n        status_queue (queue.Queue, optional): Queue to send status updates for GUI. Defaults to None.\n    Returns:\n        str or None: The path to the created WAV file on success, otherwise None.",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "fetch_character_list_from_api",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def fetch_character_list_from_api():\n    \"\"\"\n    Fetches a list of character names from the JMP Blue Genshin API.\n    Returns:\n        list: A sorted list of unique character names, or an empty list on error.\n    \"\"\"\n    try:\n        # Get the list of character slugs (identifiers)\n        response = requests.get(f\"{JMP_API_URL_BASE}/characters\", timeout=15) # Increased timeout\n        response.raise_for_status()",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "is_silent_audio",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def is_silent_audio(file_path, silence_threshold=-50.0, chunk_size=10):\n    \"\"\"\n    Checks if a WAV file is likely silent or very quiet.\n    Args:\n        file_path (str): Path to the WAV file.\n        silence_threshold (float): The dBFS threshold below which audio is considered silent. Defaults to -50.0.\n        chunk_size (int): Size of chunks (in ms) to check for silence. Defaults to 10.\n    Returns:\n        bool: True if the audio's maximum dBFS is below the threshold, False otherwise.\n              Returns True if an error occurs during processing (treats errors as silence).",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "clean_metadata_file",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def clean_metadata_file(metadata_path):\n    \"\"\"\n    Cleans a metadata CSV file, ensuring it has the correct header and format (text|audio_file|speaker_id).\n    Removes lines with incorrect column counts or empty essential fields.\n    Args:\n        metadata_path (str): Path to the metadata CSV file.\n    Returns:\n        bool: True if the file was cleaned successfully and contains at least one valid data entry, False otherwise.\n    \"\"\"\n    cleaned_lines = []",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "transcribe_character_audio",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def transcribe_character_audio(\n    character_output_dir,\n    whisper_model=\"base\",\n    use_segmentation=False,\n    hf_token=\"\",\n    strict_ascii=False,\n    status_queue=None,\n):\n    \"\"\"\n    Transcribes WAV audio files for a character using Whisper via SpeechToText.",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "validate_metadata_existence",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def validate_metadata_existence(character_dir):\n    \"\"\"Checks if metadata.csv exists and has more than just a header line.\"\"\"\n    metadata_path = os.path.join(character_dir, \"metadata.csv\")\n    if not os.path.exists(metadata_path):\n        logging.error(f\"Metadata file missing: {metadata_path}\")\n        return False\n    try:\n        with open(metadata_path, \"r\", encoding=\"utf-8\") as f:\n            lines = f.readlines()\n        # Check if file has at least 2 lines (header + one data line)",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "validate_metadata_for_training",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def validate_metadata_for_training(metadata_path):\n    \"\"\"\n    Validates if a metadata CSV file is suitable for training (correct format, columns, non-empty).\n    Args:\n        metadata_path (str): Path to the metadata file (e.g., metadata.csv or valid.csv).\n    Returns:\n        bool: True if the metadata is valid for training, False otherwise.\n    \"\"\"\n    if not os.path.exists(metadata_path):\n        logging.error(f\"Metadata file not found for validation: {metadata_path}\")",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "process_character_voices",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def process_character_voices(\n    character,\n    language, # Currently only used for category selection\n    base_output_dir,\n    download_wiki_audio=True,\n    whisper_model=\"base\",\n    use_segmentation=False,\n    hf_token=\"\",\n    strict_ascii=False,\n    status_queue=None,",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "validate_metadata_layout",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def validate_metadata_layout(metadata_path):\n    \"\"\"\n    Validates the basic layout (header, column count) of a metadata file.\n    Less strict than validate_metadata_for_training, used for initial checks.\n    Args:\n        metadata_path (str): Path to the metadata file.\n    Returns:\n        bool: True if the layout seems correct (header, 3 columns), False otherwise.\n    \"\"\"\n    if not os.path.exists(metadata_path):",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "validate_training_prerequisites",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def validate_training_prerequisites(character_dir, config_path):\n    \"\"\"\n    Validates all necessary files and formats before starting TTS training.\n    Args:\n        character_dir (str): Path to the character's data directory.\n        config_path (str): Path to the training configuration JSON file.\n    Returns:\n        bool: True if all prerequisites are met, False otherwise.\n    \"\"\"\n    logging.info(f\"--- Validating Training Prerequisites for {os.path.basename(character_dir)} ---\")",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "update_character_config",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def update_character_config(\n    character,\n    base_output_dir,\n    selected_model=\"Fast Tacotron2\",\n    batch_size=16,\n    num_epochs=100,\n    learning_rate=0.0001,\n    status_queue=None,  # Added for status updates\n):\n    \"\"\"",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "generate_valid_csv",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def generate_valid_csv(metadata_path, valid_ratio=0.1):\n    \"\"\"\n    Generates valid.csv by splitting metadata.csv. Overwrites existing valid.csv.\n    Modifies the original metadata.csv to contain only training samples.\n    Args:\n        metadata_path (str): Path to the main metadata.csv file.\n        valid_ratio (float): Fraction of data to use for the validation set. Defaults to 0.1 (10%).\n    Returns:\n        str or None: Path to the created valid.csv on success, None on failure.\n    \"\"\"",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "start_tts_training",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def start_tts_training(config_path, resume_from_checkpoint=None, status_queue=None, stop_event=None):\n    \"\"\"\n    Starts the TTS model training process using the specified config file.\n    Args:\n        config_path (str): Path to the training configuration JSON file.\n        resume_from_checkpoint (str, optional): Path to a checkpoint to resume training.\n        status_queue (queue.Queue, optional): Queue for GUI status updates.\n        stop_event (threading.Event, optional): Event to signal cancellation.\n    Returns:\n        bool: True if training completes successfully, False otherwise.",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "test_trained_model",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def test_trained_model(config_path, test_text=\"Hello, this is a test of the trained model!\", output_wav=\"test_output.wav\", status_queue=None):\n    \"\"\"\n    Tests the latest trained TTS model by synthesizing sample text.\n    Args:\n        config_path (str): Path to the configuration JSON file used for training.\n        test_text (str): The text to synthesize.\n        output_wav (str): The filename for the output WAV file (saved in model's output dir).\n        status_queue (queue.Queue, optional): Queue for GUI status updates. Defaults to None.\n    Returns:\n        str or False: The path to the generated WAV file on success, False on failure.",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "find_latest_checkpoint",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def find_latest_checkpoint(output_path):\n    \"\"\"\n    Finds the latest Coqui TTS checkpoint file (model.pth or checkpoint_*.pth) in the output directory.\n    Args:\n        output_path (str): The directory where training outputs (checkpoints) are saved.\n    Returns:\n        str or None: The path to the latest checkpoint file, or None if none are found.\n    \"\"\"\n    checkpoint_dir = output_path # Coqui often saves checkpoints directly in output_path or a subfolder\n    if not os.path.exists(checkpoint_dir) or not os.path.isdir(checkpoint_dir):",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "backup_file",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def backup_file(path, suffix=\"backup\"):\n    \"\"\"\n    Creates a timestamped backup of a file or directory.\n    Args:\n        path (str): The path to the file or directory to back up.\n        suffix (str): A suffix to add before the timestamp in the backup name. Defaults to \"backup\".\n    \"\"\"\n    if os.path.exists(path):\n        timestamp = datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")\n        # Insert suffix before the extension for files",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "has_trained_model",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def has_trained_model(character, base_output_dir):\n    \"\"\"\n    Checks if a trained model (config and at least one checkpoint) exists for the character.\n    Args:\n        character (str): The character name.\n        base_output_dir (str): The base directory containing character folders.\n    Returns:\n        bool: True if a config and a checkpoint are found, False otherwise.\n    \"\"\"\n    safe_character_name = re.sub(r'[\\\\/*?:\"<>|]', \"_\", character)",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "speak_tts",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def speak_tts(config_path, text, character, status_queue=None, stop_event=None):\n    \"\"\"\n    Synthesizes speech using the latest trained model for the character and plays it.\n    Args:\n        config_path (str): Path to the character's training configuration JSON file.\n        text (str): The text to synthesize.\n        character (str): The character name (used for naming output file).\n        status_queue (queue.Queue, optional): Queue for GUI status updates. Defaults to None.\n        stop_event (threading.Event, optional): Event to signal cancellation. Defaults to None.\n    Returns:",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "validate_gui_parameters",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def validate_gui_parameters(batch_size_var, num_epochs_var, learning_rate_var):\n    \"\"\"Validates numeric parameters from GUI StringVars. Returns dict or None.\"\"\"\n    params = {}\n    try:\n        params[\"batch_size\"] = int(batch_size_var.get())\n        if params[\"batch_size\"] <= 0:\n            raise ValueError(\"Batch size must be positive.\")\n    except ValueError:\n        messagebox.showerror(\"Validation Error\", \"Invalid Batch Size. Must be a positive integer.\", parent=window)\n        return None",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "main_gui",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def main_gui():\n    \"\"\"Sets up and runs the main Tkinter GUI.\"\"\"\n    global window, tts_frame, status_queue, stop_event, current_thread\n    window = tk.Tk()\n    window.title(\"Genshin Impact Voice Toolkit\")\n    window.geometry(\"650x650\") # Set a default size\n    # --- Main Frame ---\n    main_frame = ttk.Frame(window, padding=\"10\")\n    main_frame.pack(fill=tk.BOTH, expand=True)\n    # Make the main column expandable",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "BASE_DATA_DIR",
        "kind": 5,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "BASE_DATA_DIR = \"voice_datasets\" # Default directory for datasets\nWIKI_API_URL = \"https://genshin-impact.fandom.com/api.php\" # Wiki API endpoint\nJMP_API_URL_BASE = \"https://genshin.jmp.blue\" # API for character list\n# --- Available TTS Models ---\n# Dictionary mapping user-friendly names to Coqui TTS model identifiers and properties\nAVAILABLE_MODELS = {\n    \"Fast Tacotron2\": {\n        \"model_id\": \"tts_models/en/ljspeech/tacotron2-DDC\", # Coqui TTS model identifier\n        \"use_pre_trained\": True, # Whether to use the pre-trained weights as a base\n    },",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "WIKI_API_URL",
        "kind": 5,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "WIKI_API_URL = \"https://genshin-impact.fandom.com/api.php\" # Wiki API endpoint\nJMP_API_URL_BASE = \"https://genshin.jmp.blue\" # API for character list\n# --- Available TTS Models ---\n# Dictionary mapping user-friendly names to Coqui TTS model identifiers and properties\nAVAILABLE_MODELS = {\n    \"Fast Tacotron2\": {\n        \"model_id\": \"tts_models/en/ljspeech/tacotron2-DDC\", # Coqui TTS model identifier\n        \"use_pre_trained\": True, # Whether to use the pre-trained weights as a base\n    },\n    \"High-Quality VITS\": {",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "JMP_API_URL_BASE",
        "kind": 5,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "JMP_API_URL_BASE = \"https://genshin.jmp.blue\" # API for character list\n# --- Available TTS Models ---\n# Dictionary mapping user-friendly names to Coqui TTS model identifiers and properties\nAVAILABLE_MODELS = {\n    \"Fast Tacotron2\": {\n        \"model_id\": \"tts_models/en/ljspeech/tacotron2-DDC\", # Coqui TTS model identifier\n        \"use_pre_trained\": True, # Whether to use the pre-trained weights as a base\n    },\n    \"High-Quality VITS\": {\n        \"model_id\": \"tts_models/multilingual/multi-dataset/vits\", # Coqui TTS VITS model",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "AVAILABLE_MODELS",
        "kind": 5,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "AVAILABLE_MODELS = {\n    \"Fast Tacotron2\": {\n        \"model_id\": \"tts_models/en/ljspeech/tacotron2-DDC\", # Coqui TTS model identifier\n        \"use_pre_trained\": True, # Whether to use the pre-trained weights as a base\n    },\n    \"High-Quality VITS\": {\n        \"model_id\": \"tts_models/multilingual/multi-dataset/vits\", # Coqui TTS VITS model\n        \"use_pre_trained\": False, # VITS often trained from scratch or fine-tuned differently\n    },\n    # Add more models here if needed",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "window",
        "kind": 5,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "window = None\ntts_frame = None\nstatus_queue = queue.Queue() # Queue for thread communication\nstop_event = threading.Event() # Event to signal cancellation\ncurrent_thread = [None] # List to hold the currently running background thread\n# Helper function for GUI parameter validation\ndef validate_gui_parameters(batch_size_var, num_epochs_var, learning_rate_var):\n    \"\"\"Validates numeric parameters from GUI StringVars. Returns dict or None.\"\"\"\n    params = {}\n    try:",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "tts_frame",
        "kind": 5,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "tts_frame = None\nstatus_queue = queue.Queue() # Queue for thread communication\nstop_event = threading.Event() # Event to signal cancellation\ncurrent_thread = [None] # List to hold the currently running background thread\n# Helper function for GUI parameter validation\ndef validate_gui_parameters(batch_size_var, num_epochs_var, learning_rate_var):\n    \"\"\"Validates numeric parameters from GUI StringVars. Returns dict or None.\"\"\"\n    params = {}\n    try:\n        params[\"batch_size\"] = int(batch_size_var.get())",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "status_queue",
        "kind": 5,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "status_queue = queue.Queue() # Queue for thread communication\nstop_event = threading.Event() # Event to signal cancellation\ncurrent_thread = [None] # List to hold the currently running background thread\n# Helper function for GUI parameter validation\ndef validate_gui_parameters(batch_size_var, num_epochs_var, learning_rate_var):\n    \"\"\"Validates numeric parameters from GUI StringVars. Returns dict or None.\"\"\"\n    params = {}\n    try:\n        params[\"batch_size\"] = int(batch_size_var.get())\n        if params[\"batch_size\"] <= 0:",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "stop_event",
        "kind": 5,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "stop_event = threading.Event() # Event to signal cancellation\ncurrent_thread = [None] # List to hold the currently running background thread\n# Helper function for GUI parameter validation\ndef validate_gui_parameters(batch_size_var, num_epochs_var, learning_rate_var):\n    \"\"\"Validates numeric parameters from GUI StringVars. Returns dict or None.\"\"\"\n    params = {}\n    try:\n        params[\"batch_size\"] = int(batch_size_var.get())\n        if params[\"batch_size\"] <= 0:\n            raise ValueError(\"Batch size must be positive.\")",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "current_thread",
        "kind": 5,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "current_thread = [None] # List to hold the currently running background thread\n# Helper function for GUI parameter validation\ndef validate_gui_parameters(batch_size_var, num_epochs_var, learning_rate_var):\n    \"\"\"Validates numeric parameters from GUI StringVars. Returns dict or None.\"\"\"\n    params = {}\n    try:\n        params[\"batch_size\"] = int(batch_size_var.get())\n        if params[\"batch_size\"] <= 0:\n            raise ValueError(\"Batch size must be positive.\")\n    except ValueError:",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "parse_arguments",
        "kind": 2,
        "importPath": "test_trained_model",
        "description": "test_trained_model",
        "peekOfCode": "def parse_arguments():\n    parser = argparse.ArgumentParser(description=\"Test a trained TTS model for a specific character.\")\n    parser.add_argument(\"--character\", type=str, required=True,\n                        help=\"Name of the character whose trained model you want to test.\")\n    parser.add_argument(\"--text\", type=str, required=True,\n                        help=\"Text to synthesize using the character's model.\")\n    parser.add_argument(\"--output_file\", type=str, default=None,\n                        help=\"Optional: Path to save the generated WAV file. If not provided, defaults to 'character_test_output.wav'.\")\n    parser.add_argument(\"--base_model_dir\", type=str, default=BASE_MODEL_DIR,\n                        help=f\"Base directory containing all trained character models (default: {BASE_MODEL_DIR})\")",
        "detail": "test_trained_model",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "test_trained_model",
        "description": "test_trained_model",
        "peekOfCode": "def main():\n    args = parse_arguments()\n    # --- Determine Paths ---\n    # Sanitize character name similar to how VoiceTrainer does it\n    character_name_sanitized = args.character # Assume CLI passes sanitized name or handle here if needed\n    character_model_dir = os.path.join(args.base_model_dir, character_name_sanitized)\n    # Expecting standard output structure from training (best_model.pth, config.json)\n    trained_model_path = os.path.join(character_model_dir, \"best_model.pth\")\n    trained_config_path = os.path.join(character_model_dir, \"config.json\")\n    # Determine output filename",
        "detail": "test_trained_model",
        "documentation": {}
    },
    {
        "label": "BASE_MODEL_DIR",
        "kind": 5,
        "importPath": "test_trained_model",
        "description": "test_trained_model",
        "peekOfCode": "BASE_MODEL_DIR = \"trained_models\"   # Base directory where character models are saved\n# --- Argument Parser ---\ndef parse_arguments():\n    parser = argparse.ArgumentParser(description=\"Test a trained TTS model for a specific character.\")\n    parser.add_argument(\"--character\", type=str, required=True,\n                        help=\"Name of the character whose trained model you want to test.\")\n    parser.add_argument(\"--text\", type=str, required=True,\n                        help=\"Text to synthesize using the character's model.\")\n    parser.add_argument(\"--output_file\", type=str, default=None,\n                        help=\"Optional: Path to save the generated WAV file. If not provided, defaults to 'character_test_output.wav'.\")",
        "detail": "test_trained_model",
        "documentation": {}
    },
    {
        "label": "TestVoiceTrainer",
        "kind": 6,
        "importPath": "test_voice_tools",
        "description": "test_voice_tools",
        "peekOfCode": "class TestVoiceTrainer(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Set up a temporary dataset directory for testing.\"\"\"\n        self.character_name = \"TestCharacter\"\n        self.trainer = VoiceTrainer(character_name=self.character_name)\n        os.makedirs(self.trainer.dataset_path, exist_ok=True)\n        os.makedirs(self.trainer.output_path, exist_ok=True)\n        # Create a valid test audio file\n        self.test_audio_path = os.path.join(self.trainer.dataset_path, \"test.wav\")\n        sample_rate = 22050",
        "detail": "test_voice_tools",
        "documentation": {}
    },
    {
        "label": "RobustTokenizer",
        "kind": 6,
        "importPath": "voice_clone_train",
        "description": "voice_clone_train",
        "peekOfCode": "class RobustTokenizer(TTSTokenizer):\n    def __init__(self, characters=None, **kwargs):\n        if characters is None:\n            characters = BaseCharacters()\n        super().__init__(characters=characters, **kwargs)\n    def encode(self, text):\n        try:\n            return [self.characters.char_to_id(char) for char in text]\n        except KeyError as e:\n            logger.warning(f\"Skipping invalid character {repr(e)} in text: {text}\")",
        "detail": "voice_clone_train",
        "documentation": {}
    },
    {
        "label": "custom_formatter",
        "kind": 2,
        "importPath": "voice_clone_train",
        "description": "voice_clone_train",
        "peekOfCode": "def custom_formatter(root_path, meta_file, **kwargs):\n    items = []\n    try:\n        with open(os.path.join(root_path, meta_file), \"r\", encoding=\"utf-8\") as f:\n            for line in f:\n                parts = line.strip().split(\"|\")\n                if len(parts) < 2 or parts[0] == \"audio_file\":\n                    continue\n                audio_file = os.path.join(root_path, parts[0])\n                text = clean_text(parts[1])",
        "detail": "voice_clone_train",
        "documentation": {}
    },
    {
        "label": "clean_text",
        "kind": 2,
        "importPath": "voice_clone_train",
        "description": "voice_clone_train",
        "peekOfCode": "def clean_text(text):\n    supported_chars = set(\n        \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 .,!?'\\\"-:\"\n    )\n    original_length = len(text)\n    cleaned_text = \"\".join(c for c in text if c in supported_chars)\n    if len(cleaned_text) != original_length:\n        logger.debug(f\"Cleaned text: Original='{text}', Cleaned='{cleaned_text}'\")\n    return cleaned_text\n# Vocabulary Management",
        "detail": "voice_clone_train",
        "documentation": {}
    },
    {
        "label": "update_vocabulary",
        "kind": 2,
        "importPath": "voice_clone_train",
        "description": "voice_clone_train",
        "peekOfCode": "def update_vocabulary(vocabulary_path, new_characters):\n    try:\n        if os.path.exists(vocabulary_path):\n            with open(vocabulary_path, \"r\", encoding=\"utf-8\") as f:\n                existing_vocab = set(f.read().strip())\n        else:\n            existing_vocab = set()\n        updated_vocab = existing_vocab.union(new_characters)\n        if updated_vocab != existing_vocab:\n            with open(vocabulary_path, \"w\", encoding=\"utf-8\") as f:",
        "detail": "voice_clone_train",
        "documentation": {}
    },
    {
        "label": "ensure_phoneme_vocabulary",
        "kind": 2,
        "importPath": "voice_clone_train",
        "description": "voice_clone_train",
        "peekOfCode": "def ensure_phoneme_vocabulary(config):\n    logger = get_logger(\"ensure_phoneme_vocabulary\")\n    try:\n        gruut_phonemes = set(\n            [\n                \"a\", \"b\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\",\n                \"p\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"z\", \"\", \"\", \"\", \"\", \"\", \"\",\n                \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n                \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"\n            ]",
        "detail": "voice_clone_train",
        "documentation": {}
    },
    {
        "label": "safe_delete",
        "kind": 2,
        "importPath": "voice_clone_train",
        "description": "voice_clone_train",
        "peekOfCode": "def safe_delete(file_path, retries=10, delay=3):\n    for attempt in range(retries):\n        try:\n            if os.path.exists(file_path):\n                os.unlink(file_path)\n                logger.info(f\"Deleted file: {file_path}\")\n            return\n        except PermissionError:\n            logger.warning(\n                f\"Attempt {attempt + 1}/{retries}: PermissionError deleting {file_path}. Retrying in {delay}s...\"",
        "detail": "voice_clone_train",
        "documentation": {}
    },
    {
        "label": "safe_remove_experiment_folder",
        "kind": 2,
        "importPath": "voice_clone_train",
        "description": "voice_clone_train",
        "peekOfCode": "def safe_remove_experiment_folder(path, retries=10, delay=3):\n    for attempt in range(retries):\n        try:\n            if os.path.exists(path):\n                shutil.rmtree(path, ignore_errors=False)\n                logger.info(f\"Removed directory tree: {path}\")\n            return\n        except PermissionError:\n            logger.warning(\n                f\"Attempt {attempt + 1}/{retries}: PermissionError removing {path}. Retrying in {delay}s...\"",
        "detail": "voice_clone_train",
        "documentation": {}
    },
    {
        "label": "plot_results",
        "kind": 2,
        "importPath": "voice_clone_train",
        "description": "voice_clone_train",
        "peekOfCode": "def plot_results(y_hat, y, ap, name_prefix):\n    try:\n        if isinstance(y_hat, torch.Tensor):\n            y_hat = y_hat.squeeze().detach().cpu().float().numpy()\n        if isinstance(y, torch.Tensor):\n            y = y.squeeze().detach().cpu().float().numpy()\n        if y_hat is None or y is None or y_hat.size == 0 or y.size == 0:\n            logger.warning(\"Invalid or empty audio data received for plotting.\")\n            return\n        y_hat_spec = (",
        "detail": "voice_clone_train",
        "documentation": {}
    },
    {
        "label": "parse_arguments",
        "kind": 2,
        "importPath": "voice_clone_train",
        "description": "voice_clone_train",
        "peekOfCode": "def parse_arguments():\n    parser = argparse.ArgumentParser(\n        description=\"Train a VITS TTS model for a specific character.\"\n    )\n    parser.add_argument(\n        \"--dataset_path\", type=str, required=True, help=\"Path to dataset directory.\"\n    )\n    parser.add_argument(\n        \"--output_path\",\n        type=str,",
        "detail": "voice_clone_train",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "voice_clone_train",
        "description": "voice_clone_train",
        "peekOfCode": "def main():\n    args = parse_arguments()\n    # Setup Logging\n    log_level_map = {\n        \"DEBUG\": logging.DEBUG,\n        \"INFO\": logging.INFO,\n        \"WARNING\": logging.WARNING,\n        \"ERROR\": logging.ERROR,\n        \"CRITICAL\": logging.CRITICAL,\n    }",
        "detail": "voice_clone_train",
        "documentation": {}
    },
    {
        "label": "os.environ[\"PYTHONUTF8\"]",
        "kind": 5,
        "importPath": "voice_clone_train",
        "description": "voice_clone_train",
        "peekOfCode": "os.environ[\"PYTHONUTF8\"] = \"1\"\n# Import enhanced_logger\ntry:\n    from enhanced_logger import setup_logger, get_logger\nexcept ImportError:\n    logging.basicConfig(\n        level=logging.INFO,\n        format=\"%(asctime)s - %(levelname)s - %(message)s\",\n        handlers=[logging.StreamHandler()],\n    )",
        "detail": "voice_clone_train",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "voice_clone_train",
        "description": "voice_clone_train",
        "peekOfCode": "logger = get_logger(__name__)\n# Constants\nMETADATA_FILENAME = \"metadata.csv\"\n# Robust Tokenizer to handle invalid characters\nclass RobustTokenizer(TTSTokenizer):\n    def __init__(self, characters=None, **kwargs):\n        if characters is None:\n            characters = BaseCharacters()\n        super().__init__(characters=characters, **kwargs)\n    def encode(self, text):",
        "detail": "voice_clone_train",
        "documentation": {}
    },
    {
        "label": "METADATA_FILENAME",
        "kind": 5,
        "importPath": "voice_clone_train",
        "description": "voice_clone_train",
        "peekOfCode": "METADATA_FILENAME = \"metadata.csv\"\n# Robust Tokenizer to handle invalid characters\nclass RobustTokenizer(TTSTokenizer):\n    def __init__(self, characters=None, **kwargs):\n        if characters is None:\n            characters = BaseCharacters()\n        super().__init__(characters=characters, **kwargs)\n    def encode(self, text):\n        try:\n            return [self.characters.char_to_id(char) for char in text]",
        "detail": "voice_clone_train",
        "documentation": {}
    },
    {
        "label": "SpeechToText",
        "kind": 6,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "class SpeechToText:\n    \"\"\"\n    Handles Speech-to-Text (STT) with audio preprocessing and engine selection.\n    Includes noise reduction, normalization, and resampling for improved accuracy.\n    Supports engines: 'google', 'sphinx', 'whisper', 'vosk'.\n    \"\"\"\n    def __init__(\n        self,\n        use_microphone: bool = True,\n        audio_file: Optional[str] = None,",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "TextToSpeech",
        "kind": 6,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "class TextToSpeech:\n    \"\"\" Handles standard Text-to-Speech (TTS) using pyttsx3 or gTTS. \"\"\"\n    def __init__(\n        self,\n        use_pyttsx3: bool = True,\n        voice_name: Optional[str] = None,\n        speech_rate: int = 150,\n        lang: str = \"en\",\n    ) -> None:\n        self.use_pyttsx3 = use_pyttsx3",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "ClonedVoiceTTS",
        "kind": 6,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "class ClonedVoiceTTS:\n    \"\"\" Handles Text-to-Speech (TTS) using voice cloning models (e.g., XTTS). \"\"\"\n    def __init__(\n        self,\n        model_name: str = \"tts_models/multilingual/multi-dataset/xtts_v2\",\n        reference_wavs: Union[str, List[str]] = None,\n        use_gpu: bool = True,\n    ):\n        if CoquiTTS is None:\n            raise ImportError(\"TTS library is required for ClonedVoiceTTS but not found.\")",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "VoiceTrainer",
        "kind": 6,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "class VoiceTrainer:\n    \"\"\" Handles voice training dataset management and interaction with training scripts for specific characters. \"\"\"\n    def __init__(self, character_name: str, base_dataset_dir: str = BASE_DATASET_DIR, base_model_dir: str = BASE_MODEL_DIR):\n        \"\"\"\n        Initializes the VoiceTrainer for a specific character.\n        Args:\n            character_name: The name of the character (used for directory paths).\n            base_dataset_dir: The root directory containing all character datasets.\n            base_model_dir: The root directory containing all trained character models.\n        \"\"\"",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "play_audio_with_pydub",
        "kind": 2,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "def play_audio_with_pydub(file_path):\n    \"\"\"\n    Plays an audio file using pydub. Handles various formats.\n    Args:\n        file_path: Path to the audio file to play.\n    \"\"\"\n    try:\n        audio = AudioSegment.from_file(file_path)\n        print(f\"Attempting to play audio with pydub: {file_path}\")\n        play(audio)",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "play_audio_with_simpleaudio",
        "kind": 2,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "def play_audio_with_simpleaudio(file_path):\n    \"\"\"\n    Plays a WAV audio file using simpleaudio.\n    Args:\n        file_path: Path to the WAV audio file to play.\n    \"\"\"\n    try:\n        print(f\"Attempting to play audio with simpleaudio: {file_path}\")\n        if not file_path.lower().endswith(\".wav\"):\n             print(\"Simpleaudio fallback requires WAV format. Skipping playback.\")",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "play_audio",
        "kind": 2,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "def play_audio(file_path):\n    \"\"\"\n    Plays an audio file using pydub or simpleaudio as fallback (for WAV).\n    Args:\n        file_path: Path to the audio file to play.\n    \"\"\"\n    try:\n        play_audio_with_pydub(file_path)\n    except Exception as e:\n        print(f\"Pydub playback failed ({e}). Falling back to simpleaudio for WAV if applicable.\")",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "measure_execution_time",
        "kind": 2,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "def measure_execution_time(func):\n    \"\"\" Decorator to measure the execution time of a function. \"\"\"\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        logging.info(f\"Function '{func.__name__}' executed in: {end_time - start_time:.2f} seconds\")\n        return result\n    return wrapper\n# Function to use `scipy.io.wavfile.read` for reading WAV files",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "read_wav_file_scipy",
        "kind": 2,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "def read_wav_file_scipy(file_path):\n    \"\"\" Reads a WAV file using Scipy and returns the sample rate and data. \"\"\"\n    try:\n        sample_rate, data = read_wav(file_path)\n        logging.debug(f\"Read WAV file (SciPy): {file_path} (Sample Rate: {sample_rate}, Data Shape: {data.shape})\")\n        return sample_rate, data\n    except Exception as e:\n        logging.error(f\"Error reading WAV file with SciPy: {e}\")\n        return None, None\n# Example usage of AudioProcessor (if TTS is installed)",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "process_audio_sample_coqui",
        "kind": 2,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "def process_audio_sample_coqui(audio_file):\n    \"\"\" Processes an audio file using Coqui TTS AudioProcessor. \"\"\"\n    if AudioProcessor is None:\n        print(\"AudioProcessor not available (TTS library missing).\")\n        return None\n    try:\n        # Example config - adjust as needed for your TTS model\n        ap = AudioProcessor(sample_rate=22050, num_mels=80)\n        processed_audio = ap.load_wav(audio_file)\n        logging.info(\"Audio processing with Coqui AudioProcessor complete.\")",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "record_and_play_sd",
        "kind": 2,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "def record_and_play_sd(duration=5, sample_rate=44100, device_index=None):\n    \"\"\" Records audio and plays it back using sounddevice. \"\"\"\n    logging.info(f\"Recording audio (sounddevice) for {duration} seconds...\")\n    try:\n        audio_data = sd.rec(int(duration * sample_rate), samplerate=sample_rate, channels=1, device_index=device_index, dtype=\"int16\")\n        sd.wait()\n        logging.info(\"Finished recording. Playing back (sounddevice)...\")\n        sd.play(audio_data, samplerate=sample_rate)\n        sd.wait()\n        return audio_data",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "save_wave_file_scipy",
        "kind": 2,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "def save_wave_file_scipy(audio_data: np.ndarray, filename: str, sample_rate: int = 44100) -> None:\n    \"\"\" Saves audio data (numpy array) to WAV using scipy.io.wavfile. \"\"\"\n    if audio_data is None:\n        logging.error(\"No audio data provided to save.\")\n        return\n    logging.info(f\"Saving audio data (scipy) to WAV file: {filename}\")\n    try:\n        write_wav(filename, sample_rate, audio_data)\n        logging.info(\"WAV file saved successfully (scipy).\")\n    except Exception as e:",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "get_audio_device_list",
        "kind": 2,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "def get_audio_device_list():\n    \"\"\" Prints a list of available audio input/output devices using sounddevice. \"\"\"\n    print(\"\\n--- Available Audio Devices (Sounddevice) ---\")\n    try:\n        devices = sd.query_devices()\n        default_input_idx = sd.default.device[0]\n        default_output_idx = sd.default.device[1]\n        print(\"Input Devices:\")\n        found_input = False\n        for i, device in enumerate(devices):",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "BASE_DATASET_DIR",
        "kind": 5,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "BASE_DATASET_DIR = \"voice_datasets\" # Base directory for all character datasets\nBASE_MODEL_DIR = \"trained_models\"   # Base directory for all trained character models\nMETADATA_FILENAME = \"metadata.csv\"  # Standard metadata filename\n# --- Helper Functions ---\n# Function to play audio using pydub\ndef play_audio_with_pydub(file_path):\n    \"\"\"\n    Plays an audio file using pydub. Handles various formats.\n    Args:\n        file_path: Path to the audio file to play.",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "BASE_MODEL_DIR",
        "kind": 5,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "BASE_MODEL_DIR = \"trained_models\"   # Base directory for all trained character models\nMETADATA_FILENAME = \"metadata.csv\"  # Standard metadata filename\n# --- Helper Functions ---\n# Function to play audio using pydub\ndef play_audio_with_pydub(file_path):\n    \"\"\"\n    Plays an audio file using pydub. Handles various formats.\n    Args:\n        file_path: Path to the audio file to play.\n    \"\"\"",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "METADATA_FILENAME",
        "kind": 5,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "METADATA_FILENAME = \"metadata.csv\"  # Standard metadata filename\n# --- Helper Functions ---\n# Function to play audio using pydub\ndef play_audio_with_pydub(file_path):\n    \"\"\"\n    Plays an audio file using pydub. Handles various formats.\n    Args:\n        file_path: Path to the audio file to play.\n    \"\"\"\n    try:",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "voice_trainer_cli",
        "description": "voice_trainer_cli",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        description=\"Voice Trainer CLI Tool - Manages datasets and training for specific characters.\",\n        formatter_class=argparse.RawTextHelpFormatter,\n    )\n    # Required Arguments\n    parser.add_argument(\n        \"--character\",\n        type=str,\n        required=True,",
        "detail": "voice_trainer_cli",
        "documentation": {}
    },
    {
        "label": "script_dir",
        "kind": 5,
        "importPath": "voice_trainer_cli",
        "description": "voice_trainer_cli",
        "peekOfCode": "script_dir = os.path.dirname(os.path.abspath(__file__))\nos.chdir(script_dir)\nsys.path.insert(0, script_dir)  # Add script directory to sys.path\ntry:\n    from voice_tools import VoiceTrainer, BASE_DATASET_DIR, BASE_MODEL_DIR\nexcept ImportError:\n    print(\"Error: voice_tools.py not found. Make sure it's in the same directory.\")\n    logging.error(\"Failed to import from voice_tools.py\")\n    sys.exit(1)\n# Configure logging",
        "detail": "voice_trainer_cli",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "voice_trainer_cli",
        "description": "voice_trainer_cli",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef main():\n    parser = argparse.ArgumentParser(\n        description=\"Voice Trainer CLI Tool - Manages datasets and training for specific characters.\",\n        formatter_class=argparse.RawTextHelpFormatter,\n    )\n    # Required Arguments\n    parser.add_argument(\n        \"--character\",\n        type=str,",
        "detail": "voice_trainer_cli",
        "documentation": {}
    },
    {
        "label": "run_command_with_output",
        "kind": 2,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "def run_command_with_output(command, output_text_widget):\n    \"\"\"\n    Run a shell command and display its output in the GUI.\n    Args:\n        command (str): The command to run.\n        output_text_widget (tk.Text): The text widget to display the output.\n    \"\"\"\n    def target():\n        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True, text=True)\n        for line in process.stdout:",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "start_training",
        "kind": 2,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "def start_training(character, action, epochs, batch_size, learning_rate, text=None, file=None):\n    \"\"\"\n    Start the training or dataset management process with the provided parameters and display output in the GUI.\n    Args:\n        character (str): Character name.\n        action (str): Action to perform.\n        epochs (int): Number of training epochs (for training).\n        batch_size (int): Batch size for training.\n        learning_rate (float): Learning rate for training.\n        text (str, optional): Text for 'test' or 'use' actions.",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "fetch_character_list",
        "kind": 2,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "def fetch_character_list():\n    \"\"\"\n    Fetches a list of character names based on subdirectories in the voice_datasets folder.\n    Returns:\n        list: A sorted list of character names.\n    \"\"\"\n    base_dir = \"voice_datasets\"\n    try:\n        if not os.path.exists(base_dir):\n            return []",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "update_epochs_label",
        "kind": 2,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "def update_epochs_label(value):\n    epochs_value_label.config(text=f\"Epochs: {value}\")\n# Configure the epochs slider to call the update function\nepochs_scale.config(command=update_epochs_label)\nttk.Label(parameters_frame, text=\"Batch Size:\").grid(row=5, column=0, sticky=\"w\", padx=5, pady=5)\nbatch_size_scale = Scale(parameters_frame, from_=1, to=128, orient=tk.HORIZONTAL)\nbatch_size_scale.set(16)\nbatch_size_scale.grid(row=5, column=1, sticky=\"ew\", padx=5, pady=5)\n# Add a label to display the current value of the batch size slider\nbatch_size_value_label = ttk.Label(parameters_frame, text=f\"Batch Size: {batch_size_scale.get()}\")",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "update_batch_size_label",
        "kind": 2,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "def update_batch_size_label(value):\n    batch_size_value_label.config(text=f\"Batch Size: {value}\")\n# Configure the batch size slider to call the update function\nbatch_size_scale.config(command=update_batch_size_label)\nttk.Label(parameters_frame, text=\"Learning Rate:\").grid(row=6, column=0, sticky=\"w\", padx=5, pady=5)\nlearning_rate_scale = tk.Scale(parameters_frame, from_=0.0001, to=0.01, resolution=0.0001, orient=tk.HORIZONTAL)\nlearning_rate_scale.set(0.0002)\nlearning_rate_scale.grid(row=6, column=1, sticky=\"ew\", padx=5, pady=5)\n# Add a label to display the current value of the learning rate slider\nlearning_rate_value_label = ttk.Label(parameters_frame, text=f\"Learning Rate: {learning_rate_scale.get():.4f}\")",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "update_learning_rate_label",
        "kind": 2,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "def update_learning_rate_label(value):\n    learning_rate_value_label.config(text=f\"Learning Rate: {float(value):.4f}\")\n# Configure the learning rate slider to call the update function\nlearning_rate_scale.config(command=update_learning_rate_label)\n# Start Training Button\ndef on_start_training():\n    character = character_var.get()\n    action = action_var.get()\n    # Cast epochs to an integer before passing to start_training\n    epochs = int(epochs_scale.get())",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "on_start_training",
        "kind": 2,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "def on_start_training():\n    character = character_var.get()\n    action = action_var.get()\n    # Cast epochs to an integer before passing to start_training\n    epochs = int(epochs_scale.get())\n    # Cast batch_size to an integer before passing to start_training\n    batch_size = int(batch_size_scale.get())\n    learning_rate = learning_rate_scale.get()\n    if not character:\n        messagebox.showerror(\"Error\", \"Please select a character.\")",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "root = tk.Tk()\nroot.title(\"Voice Trainer GUI\")\nroot.geometry(\"500x400\")\n# Use a Notebook widget to organize sections\nnotebook = ttk.Notebook(root)\nnotebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n# Create frames for different sections\nparameters_frame = ttk.Frame(notebook)\noutput_frame = ttk.Frame(notebook)\nnotebook.add(parameters_frame, text=\"Parameters\")",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "notebook",
        "kind": 5,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "notebook = ttk.Notebook(root)\nnotebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n# Create frames for different sections\nparameters_frame = ttk.Frame(notebook)\noutput_frame = ttk.Frame(notebook)\nnotebook.add(parameters_frame, text=\"Parameters\")\nnotebook.add(output_frame, text=\"Output\")\n# Character Selection\ncharacter_list = fetch_character_list()\ncharacter_var = tk.StringVar(root)",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "parameters_frame",
        "kind": 5,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "parameters_frame = ttk.Frame(notebook)\noutput_frame = ttk.Frame(notebook)\nnotebook.add(parameters_frame, text=\"Parameters\")\nnotebook.add(output_frame, text=\"Output\")\n# Character Selection\ncharacter_list = fetch_character_list()\ncharacter_var = tk.StringVar(root)\nif character_list:\n    character_var.set(character_list[0])  # Default to the first character\nelse:",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "output_frame",
        "kind": 5,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "output_frame = ttk.Frame(notebook)\nnotebook.add(parameters_frame, text=\"Parameters\")\nnotebook.add(output_frame, text=\"Output\")\n# Character Selection\ncharacter_list = fetch_character_list()\ncharacter_var = tk.StringVar(root)\nif character_list:\n    character_var.set(character_list[0])  # Default to the first character\nelse:\n    character_var.set(\"No characters found\")",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "character_list",
        "kind": 5,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "character_list = fetch_character_list()\ncharacter_var = tk.StringVar(root)\nif character_list:\n    character_var.set(character_list[0])  # Default to the first character\nelse:\n    character_var.set(\"No characters found\")\nttk.Label(parameters_frame, text=\"Select Character:\").grid(row=0, column=0, sticky=\"w\", padx=5, pady=5)\ncharacter_dropdown = ttk.Combobox(parameters_frame, textvariable=character_var, values=character_list, state=\"readonly\")\ncharacter_dropdown.grid(row=0, column=1, sticky=\"ew\", padx=5, pady=5)\n# Add a dropdown menu for selecting actions",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "character_var",
        "kind": 5,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "character_var = tk.StringVar(root)\nif character_list:\n    character_var.set(character_list[0])  # Default to the first character\nelse:\n    character_var.set(\"No characters found\")\nttk.Label(parameters_frame, text=\"Select Character:\").grid(row=0, column=0, sticky=\"w\", padx=5, pady=5)\ncharacter_dropdown = ttk.Combobox(parameters_frame, textvariable=character_var, values=character_list, state=\"readonly\")\ncharacter_dropdown.grid(row=0, column=1, sticky=\"ew\", padx=5, pady=5)\n# Add a dropdown menu for selecting actions\nactions = [",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "character_dropdown",
        "kind": 5,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "character_dropdown = ttk.Combobox(parameters_frame, textvariable=character_var, values=character_list, state=\"readonly\")\ncharacter_dropdown.grid(row=0, column=1, sticky=\"ew\", padx=5, pady=5)\n# Add a dropdown menu for selecting actions\nactions = [\n    \"record\",\n    \"provide\",\n    \"validate\",\n    \"stats\",\n    \"augment\",\n    \"trim\",",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "actions",
        "kind": 5,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "actions = [\n    \"record\",\n    \"provide\",\n    \"validate\",\n    \"stats\",\n    \"augment\",\n    \"trim\",\n    \"quality\",\n    \"train\",\n    \"test\",",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "action_var",
        "kind": 5,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "action_var = tk.StringVar(root)\naction_var.set(actions[0])  # Default to the first action\nttk.Label(parameters_frame, text=\"Select Action:\").grid(row=1, column=0, sticky=\"w\", padx=5, pady=5)\naction_dropdown = ttk.Combobox(parameters_frame, textvariable=action_var, values=actions, state=\"readonly\")\naction_dropdown.grid(row=1, column=1, sticky=\"ew\", padx=5, pady=5)\n# Dataset Path Display\nttk.Label(parameters_frame, text=\"Dataset Path (Default):\").grid(row=2, column=0, sticky=\"w\", padx=5, pady=5)\ndataset_path_label = ttk.Label(parameters_frame, text=\"voice_datasets/<character>\", relief=tk.SUNKEN, anchor=\"w\")\ndataset_path_label.grid(row=2, column=1, sticky=\"ew\", padx=5, pady=5)\n# Output Path Display",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "action_dropdown",
        "kind": 5,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "action_dropdown = ttk.Combobox(parameters_frame, textvariable=action_var, values=actions, state=\"readonly\")\naction_dropdown.grid(row=1, column=1, sticky=\"ew\", padx=5, pady=5)\n# Dataset Path Display\nttk.Label(parameters_frame, text=\"Dataset Path (Default):\").grid(row=2, column=0, sticky=\"w\", padx=5, pady=5)\ndataset_path_label = ttk.Label(parameters_frame, text=\"voice_datasets/<character>\", relief=tk.SUNKEN, anchor=\"w\")\ndataset_path_label.grid(row=2, column=1, sticky=\"ew\", padx=5, pady=5)\n# Output Path Display\nttk.Label(parameters_frame, text=\"Output Path (Default):\").grid(row=3, column=0, sticky=\"w\", padx=5, pady=5)\noutput_path_label = ttk.Label(parameters_frame, text=\"trained_models/<character>\", relief=tk.SUNKEN, anchor=\"w\")\noutput_path_label.grid(row=3, column=1, sticky=\"ew\", padx=5, pady=5)",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "dataset_path_label",
        "kind": 5,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "dataset_path_label = ttk.Label(parameters_frame, text=\"voice_datasets/<character>\", relief=tk.SUNKEN, anchor=\"w\")\ndataset_path_label.grid(row=2, column=1, sticky=\"ew\", padx=5, pady=5)\n# Output Path Display\nttk.Label(parameters_frame, text=\"Output Path (Default):\").grid(row=3, column=0, sticky=\"w\", padx=5, pady=5)\noutput_path_label = ttk.Label(parameters_frame, text=\"trained_models/<character>\", relief=tk.SUNKEN, anchor=\"w\")\noutput_path_label.grid(row=3, column=1, sticky=\"ew\", padx=5, pady=5)\n# Training Parameters\nttk.Label(parameters_frame, text=\"Epochs:\").grid(row=4, column=0, sticky=\"w\", padx=5, pady=5)\nepochs_scale = Scale(parameters_frame, from_=1, to=1000, orient=tk.HORIZONTAL)\nepochs_scale.set(500)",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "output_path_label",
        "kind": 5,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "output_path_label = ttk.Label(parameters_frame, text=\"trained_models/<character>\", relief=tk.SUNKEN, anchor=\"w\")\noutput_path_label.grid(row=3, column=1, sticky=\"ew\", padx=5, pady=5)\n# Training Parameters\nttk.Label(parameters_frame, text=\"Epochs:\").grid(row=4, column=0, sticky=\"w\", padx=5, pady=5)\nepochs_scale = Scale(parameters_frame, from_=1, to=1000, orient=tk.HORIZONTAL)\nepochs_scale.set(500)\nepochs_scale.grid(row=4, column=1, sticky=\"ew\", padx=5, pady=5)\n# Add a label to display the current value of the epochs slider\nepochs_value_label = ttk.Label(parameters_frame, text=f\"Epochs: {epochs_scale.get()}\")\nepochs_value_label.grid(row=4, column=2, sticky=\"w\", padx=5, pady=5)",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "epochs_scale",
        "kind": 5,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "epochs_scale = Scale(parameters_frame, from_=1, to=1000, orient=tk.HORIZONTAL)\nepochs_scale.set(500)\nepochs_scale.grid(row=4, column=1, sticky=\"ew\", padx=5, pady=5)\n# Add a label to display the current value of the epochs slider\nepochs_value_label = ttk.Label(parameters_frame, text=f\"Epochs: {epochs_scale.get()}\")\nepochs_value_label.grid(row=4, column=2, sticky=\"w\", padx=5, pady=5)\n# Update the label dynamically as the slider is moved\ndef update_epochs_label(value):\n    epochs_value_label.config(text=f\"Epochs: {value}\")\n# Configure the epochs slider to call the update function",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "epochs_value_label",
        "kind": 5,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "epochs_value_label = ttk.Label(parameters_frame, text=f\"Epochs: {epochs_scale.get()}\")\nepochs_value_label.grid(row=4, column=2, sticky=\"w\", padx=5, pady=5)\n# Update the label dynamically as the slider is moved\ndef update_epochs_label(value):\n    epochs_value_label.config(text=f\"Epochs: {value}\")\n# Configure the epochs slider to call the update function\nepochs_scale.config(command=update_epochs_label)\nttk.Label(parameters_frame, text=\"Batch Size:\").grid(row=5, column=0, sticky=\"w\", padx=5, pady=5)\nbatch_size_scale = Scale(parameters_frame, from_=1, to=128, orient=tk.HORIZONTAL)\nbatch_size_scale.set(16)",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "batch_size_scale",
        "kind": 5,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "batch_size_scale = Scale(parameters_frame, from_=1, to=128, orient=tk.HORIZONTAL)\nbatch_size_scale.set(16)\nbatch_size_scale.grid(row=5, column=1, sticky=\"ew\", padx=5, pady=5)\n# Add a label to display the current value of the batch size slider\nbatch_size_value_label = ttk.Label(parameters_frame, text=f\"Batch Size: {batch_size_scale.get()}\")\nbatch_size_value_label.grid(row=5, column=2, sticky=\"w\", padx=5, pady=5)\n# Update the label dynamically as the slider is moved\ndef update_batch_size_label(value):\n    batch_size_value_label.config(text=f\"Batch Size: {value}\")\n# Configure the batch size slider to call the update function",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "batch_size_value_label",
        "kind": 5,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "batch_size_value_label = ttk.Label(parameters_frame, text=f\"Batch Size: {batch_size_scale.get()}\")\nbatch_size_value_label.grid(row=5, column=2, sticky=\"w\", padx=5, pady=5)\n# Update the label dynamically as the slider is moved\ndef update_batch_size_label(value):\n    batch_size_value_label.config(text=f\"Batch Size: {value}\")\n# Configure the batch size slider to call the update function\nbatch_size_scale.config(command=update_batch_size_label)\nttk.Label(parameters_frame, text=\"Learning Rate:\").grid(row=6, column=0, sticky=\"w\", padx=5, pady=5)\nlearning_rate_scale = tk.Scale(parameters_frame, from_=0.0001, to=0.01, resolution=0.0001, orient=tk.HORIZONTAL)\nlearning_rate_scale.set(0.0002)",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "learning_rate_scale",
        "kind": 5,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "learning_rate_scale = tk.Scale(parameters_frame, from_=0.0001, to=0.01, resolution=0.0001, orient=tk.HORIZONTAL)\nlearning_rate_scale.set(0.0002)\nlearning_rate_scale.grid(row=6, column=1, sticky=\"ew\", padx=5, pady=5)\n# Add a label to display the current value of the learning rate slider\nlearning_rate_value_label = ttk.Label(parameters_frame, text=f\"Learning Rate: {learning_rate_scale.get():.4f}\")\nlearning_rate_value_label.grid(row=6, column=2, sticky=\"w\", padx=5, pady=5)\n# Update the label dynamically as the slider is moved\ndef update_learning_rate_label(value):\n    learning_rate_value_label.config(text=f\"Learning Rate: {float(value):.4f}\")\n# Configure the learning rate slider to call the update function",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "learning_rate_value_label",
        "kind": 5,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "learning_rate_value_label = ttk.Label(parameters_frame, text=f\"Learning Rate: {learning_rate_scale.get():.4f}\")\nlearning_rate_value_label.grid(row=6, column=2, sticky=\"w\", padx=5, pady=5)\n# Update the label dynamically as the slider is moved\ndef update_learning_rate_label(value):\n    learning_rate_value_label.config(text=f\"Learning Rate: {float(value):.4f}\")\n# Configure the learning rate slider to call the update function\nlearning_rate_scale.config(command=update_learning_rate_label)\n# Start Training Button\ndef on_start_training():\n    character = character_var.get()",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "start_button",
        "kind": 5,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "start_button = ttk.Button(parameters_frame, text=\"Start Training\", command=on_start_training)\nstart_button.grid(row=7, column=0, columnspan=3, pady=10)\n# Add a stop button and functionality to jump to CLI output\nstop_button = ttk.Button(parameters_frame, text=\"Stop Training\", command=None)  # Placeholder for stop functionality\nstop_button.grid(row=8, column=0, columnspan=3, pady=10)\n# CLI Output Section\nttk.Label(output_frame, text=\"CLI Output:\").pack(anchor=\"w\", padx=5, pady=5)\noutput_text = tk.Text(output_frame, height=10, width=60)\noutput_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n# Adjust column weights for better resizing",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "stop_button",
        "kind": 5,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "stop_button = ttk.Button(parameters_frame, text=\"Stop Training\", command=None)  # Placeholder for stop functionality\nstop_button.grid(row=8, column=0, columnspan=3, pady=10)\n# CLI Output Section\nttk.Label(output_frame, text=\"CLI Output:\").pack(anchor=\"w\", padx=5, pady=5)\noutput_text = tk.Text(output_frame, height=10, width=60)\noutput_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n# Adjust column weights for better resizing\nparameters_frame.columnconfigure(1, weight=1)\noutput_frame.columnconfigure(0, weight=1)\n# Run the GUI",
        "detail": "voice_trainer_gui",
        "documentation": {}
    },
    {
        "label": "output_text",
        "kind": 5,
        "importPath": "voice_trainer_gui",
        "description": "voice_trainer_gui",
        "peekOfCode": "output_text = tk.Text(output_frame, height=10, width=60)\noutput_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n# Adjust column weights for better resizing\nparameters_frame.columnconfigure(1, weight=1)\noutput_frame.columnconfigure(0, weight=1)\n# Run the GUI\nroot.mainloop()",
        "detail": "voice_trainer_gui",
        "documentation": {}
    }
]