[
    {
        "label": "tkinter",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter",
        "description": "tkinter",
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "ttk",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "messagebox",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "TTS",
        "importPath": "TTS.api",
        "description": "TTS.api",
        "isExtraImport": true,
        "detail": "TTS.api",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "VoiceTrainer",
        "importPath": "voice_tools",
        "description": "voice_tools",
        "isExtraImport": true,
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "soundfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "soundfile",
        "description": "soundfile",
        "detail": "soundfile",
        "documentation": {}
    },
    {
        "label": "Trainer",
        "importPath": "trainer",
        "description": "trainer",
        "isExtraImport": true,
        "detail": "trainer",
        "documentation": {}
    },
    {
        "label": "TrainerArgs",
        "importPath": "trainer",
        "description": "trainer",
        "isExtraImport": true,
        "detail": "trainer",
        "documentation": {}
    },
    {
        "label": "BaseAudioConfig",
        "importPath": "TTS.config",
        "description": "TTS.config",
        "isExtraImport": true,
        "detail": "TTS.config",
        "documentation": {}
    },
    {
        "label": "BaseDatasetConfig",
        "importPath": "TTS.config",
        "description": "TTS.config",
        "isExtraImport": true,
        "detail": "TTS.config",
        "documentation": {}
    },
    {
        "label": "VitsConfig",
        "importPath": "TTS.tts.configs.vits_config",
        "description": "TTS.tts.configs.vits_config",
        "isExtraImport": true,
        "detail": "TTS.tts.configs.vits_config",
        "documentation": {}
    },
    {
        "label": "load_tts_samples",
        "importPath": "TTS.tts.datasets",
        "description": "TTS.tts.datasets",
        "isExtraImport": true,
        "detail": "TTS.tts.datasets",
        "documentation": {}
    },
    {
        "label": "Vits",
        "importPath": "TTS.tts.models.vits",
        "description": "TTS.tts.models.vits",
        "isExtraImport": true,
        "detail": "TTS.tts.models.vits",
        "documentation": {}
    },
    {
        "label": "AudioProcessor",
        "importPath": "TTS.utils.audio",
        "description": "TTS.utils.audio",
        "isExtraImport": true,
        "detail": "TTS.utils.audio",
        "documentation": {}
    },
    {
        "label": "speech_recognition",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "speech_recognition",
        "description": "speech_recognition",
        "detail": "speech_recognition",
        "documentation": {}
    },
    {
        "label": "pyttsx3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyttsx3",
        "description": "pyttsx3",
        "detail": "pyttsx3",
        "documentation": {}
    },
    {
        "label": "sounddevice",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sounddevice",
        "description": "sounddevice",
        "detail": "sounddevice",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "write",
        "importPath": "scipy.io.wavfile",
        "description": "scipy.io.wavfile",
        "isExtraImport": true,
        "detail": "scipy.io.wavfile",
        "documentation": {}
    },
    {
        "label": "read",
        "importPath": "scipy.io.wavfile",
        "description": "scipy.io.wavfile",
        "isExtraImport": true,
        "detail": "scipy.io.wavfile",
        "documentation": {}
    },
    {
        "label": "gTTS",
        "importPath": "gtts",
        "description": "gtts",
        "isExtraImport": true,
        "detail": "gtts",
        "documentation": {}
    },
    {
        "label": "AudioSegment",
        "importPath": "pydub",
        "description": "pydub",
        "isExtraImport": true,
        "detail": "pydub",
        "documentation": {}
    },
    {
        "label": "play",
        "importPath": "pydub.playback",
        "description": "pydub.playback",
        "isExtraImport": true,
        "detail": "pydub.playback",
        "documentation": {}
    },
    {
        "label": "speedup",
        "importPath": "pydub.effects",
        "description": "pydub.effects",
        "isExtraImport": true,
        "detail": "pydub.effects",
        "documentation": {}
    },
    {
        "label": "simpleaudio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "simpleaudio",
        "description": "simpleaudio",
        "detail": "simpleaudio",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "librosa",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "librosa",
        "description": "librosa",
        "detail": "librosa",
        "documentation": {}
    },
    {
        "label": "noisereduce",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "noisereduce",
        "description": "noisereduce",
        "detail": "noisereduce",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "get_category_files",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def get_category_files(category):\n    \"\"\"Fetches file titles from a specific category on the wiki.\"\"\"\n    params = {\n        \"action\": \"query\",\n        \"list\": \"categorymembers\",\n        \"cmtype\": \"file\",\n        \"cmtitle\": category,\n        \"cmlimit\": 500,  # Fetch up to 500 files per request\n        \"format\": \"json\",\n    }",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "get_file_url",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def get_file_url(file_title):\n    \"\"\"Fetches the direct download URL for a given file title from the wiki.\"\"\"\n    params = {\n        \"action\": \"query\",\n        \"titles\": file_title,\n        \"prop\": \"imageinfo\",\n        \"iiprop\": \"url\",\n        \"format\": \"json\",\n    }\n    try:",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "download_and_convert",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def download_and_convert(file_url, output_dir, file_name, status_label=None):\n    \"\"\"Downloads an OGG file, converts it to WAV, and cleans up.\"\"\"\n    # Ensure filename is safe for filesystem\n    safe_file_name = re.sub(r'[\\\\/*?:\"<>|]', \"_\", file_name)  # Replace invalid chars\n    ogg_file_name = (\n        safe_file_name\n        if safe_file_name.lower().endswith(\".ogg\")\n        else f\"{safe_file_name}.ogg\"\n    )\n    wav_file_name = ogg_file_name.replace(\".ogg\", \".wav\").replace(",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "fetch_character_list_from_api",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def fetch_character_list_from_api():\n    \"\"\"Fetches a list of character names from the jmp.blue API.\"\"\"\n    api_url = f\"{JMP_API_URL_BASE}/characters\"\n    try:\n        logging.info(\"Fetching character list from jmp.blue API...\")\n        response = requests.get(api_url, timeout=10)\n        response.raise_for_status()\n        # The API returns a list of character slugs/IDs\n        character_slugs = response.json()\n        character_names = []",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "transcribe_character_audio",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def transcribe_character_audio(character_output_dir, status_label=None):\n    \"\"\"\n    Transcribes all WAV audio files in the specific character's output directory\n    using SpeechToText and saves the results in 'metadata.csv' within that directory.\n    Args:\n        character_output_dir: The directory containing the character's audio files.\n        status_label: Optional Tkinter label for status updates.\n    \"\"\"\n    # Check if SpeechToText is available\n    if SpeechToText is None:",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "process_character_voices",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def process_character_voices(\n    character, language, base_output_dir, download_wiki_audio=True, status_label=None\n):\n    \"\"\"\n    Downloads and converts audio files for a specific character into their dedicated folder.\n    Args:\n        character: The name of the character.\n        language: The language (used for Wiki category, e.g., \"English\").\n        base_output_dir: The base directory where all character folders will be created.\n        download_wiki_audio: Whether to download audio files from the Wiki.",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "main_gui",
        "kind": 2,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "def main_gui():\n    global window\n    window = tk.Tk()\n    window.title(\"Genshin Impact Voice Downloader & Transcriber\")\n    # --- Configuration Frame ---\n    config_frame = ttk.LabelFrame(window, text=\"Configuration\")\n    config_frame.grid(row=0, column=0, padx=10, pady=10, sticky=\"ew\")\n    # Language Selection\n    language_label = ttk.Label(config_frame, text=\"Select Language (for Wiki):\")\n    language_label.grid(row=0, column=0, padx=5, pady=5, sticky=\"w\")",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "BASE_DATA_DIR",
        "kind": 5,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "BASE_DATA_DIR = \"voice_datasets\"  # Base directory to store all character datasets\nWIKI_API_URL = \"https://genshin-impact.fandom.com/api.php\"\nJMP_API_URL_BASE = \"https://genshin.jmp.blue\"\n# --- Helper Functions ---\ndef get_category_files(category):\n    \"\"\"Fetches file titles from a specific category on the wiki.\"\"\"\n    params = {\n        \"action\": \"query\",\n        \"list\": \"categorymembers\",\n        \"cmtype\": \"file\",",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "WIKI_API_URL",
        "kind": 5,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "WIKI_API_URL = \"https://genshin-impact.fandom.com/api.php\"\nJMP_API_URL_BASE = \"https://genshin.jmp.blue\"\n# --- Helper Functions ---\ndef get_category_files(category):\n    \"\"\"Fetches file titles from a specific category on the wiki.\"\"\"\n    params = {\n        \"action\": \"query\",\n        \"list\": \"categorymembers\",\n        \"cmtype\": \"file\",\n        \"cmtitle\": category,",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "JMP_API_URL_BASE",
        "kind": 5,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "JMP_API_URL_BASE = \"https://genshin.jmp.blue\"\n# --- Helper Functions ---\ndef get_category_files(category):\n    \"\"\"Fetches file titles from a specific category on the wiki.\"\"\"\n    params = {\n        \"action\": \"query\",\n        \"list\": \"categorymembers\",\n        \"cmtype\": \"file\",\n        \"cmtitle\": category,\n        \"cmlimit\": 500,  # Fetch up to 500 files per request",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "window",
        "kind": 5,
        "importPath": "genshin_voice_downloader",
        "description": "genshin_voice_downloader",
        "peekOfCode": "window = None  # Global variable for main window (needed for update_idletasks)\ndef main_gui():\n    global window\n    window = tk.Tk()\n    window.title(\"Genshin Impact Voice Downloader & Transcriber\")\n    # --- Configuration Frame ---\n    config_frame = ttk.LabelFrame(window, text=\"Configuration\")\n    config_frame.grid(row=0, column=0, padx=10, pady=10, sticky=\"ew\")\n    # Language Selection\n    language_label = ttk.Label(config_frame, text=\"Select Language (for Wiki):\")",
        "detail": "genshin_voice_downloader",
        "documentation": {}
    },
    {
        "label": "parse_arguments",
        "kind": 2,
        "importPath": "test_trained_model",
        "description": "test_trained_model",
        "peekOfCode": "def parse_arguments():\n    parser = argparse.ArgumentParser(description=\"Test a trained TTS model for a specific character.\")\n    parser.add_argument(\"--character\", type=str, required=True,\n                        help=\"Name of the character whose trained model you want to test.\")\n    parser.add_argument(\"--text\", type=str, required=True,\n                        help=\"Text to synthesize using the character's model.\")\n    parser.add_argument(\"--output_file\", type=str, default=None,\n                        help=\"Optional: Path to save the generated WAV file. If not provided, defaults to 'character_test_output.wav'.\")\n    parser.add_argument(\"--base_model_dir\", type=str, default=BASE_MODEL_DIR,\n                        help=f\"Base directory containing all trained character models (default: {BASE_MODEL_DIR})\")",
        "detail": "test_trained_model",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "test_trained_model",
        "description": "test_trained_model",
        "peekOfCode": "def main():\n    args = parse_arguments()\n    # --- Determine Paths ---\n    # Sanitize character name similar to how VoiceTrainer does it\n    character_name_sanitized = args.character # Assume CLI passes sanitized name or handle here if needed\n    character_model_dir = os.path.join(args.base_model_dir, character_name_sanitized)\n    # Expecting standard output structure from training (best_model.pth, config.json)\n    trained_model_path = os.path.join(character_model_dir, \"best_model.pth\")\n    trained_config_path = os.path.join(character_model_dir, \"config.json\")\n    # Determine output filename",
        "detail": "test_trained_model",
        "documentation": {}
    },
    {
        "label": "BASE_MODEL_DIR",
        "kind": 5,
        "importPath": "test_trained_model",
        "description": "test_trained_model",
        "peekOfCode": "BASE_MODEL_DIR = \"trained_models\"   # Base directory where character models are saved\n# --- Argument Parser ---\ndef parse_arguments():\n    parser = argparse.ArgumentParser(description=\"Test a trained TTS model for a specific character.\")\n    parser.add_argument(\"--character\", type=str, required=True,\n                        help=\"Name of the character whose trained model you want to test.\")\n    parser.add_argument(\"--text\", type=str, required=True,\n                        help=\"Text to synthesize using the character's model.\")\n    parser.add_argument(\"--output_file\", type=str, default=None,\n                        help=\"Optional: Path to save the generated WAV file. If not provided, defaults to 'character_test_output.wav'.\")",
        "detail": "test_trained_model",
        "documentation": {}
    },
    {
        "label": "TestVoiceTrainer",
        "kind": 6,
        "importPath": "test_voice_tools",
        "description": "test_voice_tools",
        "peekOfCode": "class TestVoiceTrainer(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Set up a temporary dataset directory for testing.\"\"\"\n        self.character_name = \"TestCharacter\"\n        self.trainer = VoiceTrainer(character_name=self.character_name)\n        os.makedirs(self.trainer.dataset_path, exist_ok=True)\n        os.makedirs(self.trainer.output_path, exist_ok=True)\n        # Create a valid test audio file\n        self.test_audio_path = os.path.join(self.trainer.dataset_path, \"test.wav\")\n        sample_rate = 22050",
        "detail": "test_voice_tools",
        "documentation": {}
    },
    {
        "label": "parse_arguments",
        "kind": 2,
        "importPath": "voice_clone_train",
        "description": "voice_clone_train",
        "peekOfCode": "def parse_arguments():\n    parser = argparse.ArgumentParser(\n        description=\"Train a VITS TTS model for a specific character.\"\n    )\n    parser.add_argument(\n        \"--dataset_path\",\n        type=str,\n        required=True,\n        help=\"Path to the character's dataset directory (containing metadata.csv and wav files).\",\n    )",
        "detail": "voice_clone_train",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "voice_clone_train",
        "description": "voice_clone_train",
        "peekOfCode": "def main():\n    args = parse_arguments()\n    # --- Validate Paths ---\n    if not os.path.isdir(args.dataset_path):\n        logging.error(\n            f\"Dataset path not found or is not a directory: {args.dataset_path}\"\n        )\n        return\n    metadata_path = os.path.join(args.dataset_path, METADATA_FILENAME)\n    if not os.path.isfile(metadata_path):",
        "detail": "voice_clone_train",
        "documentation": {}
    },
    {
        "label": "METADATA_FILENAME",
        "kind": 5,
        "importPath": "voice_clone_train",
        "description": "voice_clone_train",
        "peekOfCode": "METADATA_FILENAME = \"metadata.csv\"  # Expected metadata filename in dataset folder\n# --- Argument Parser ---\ndef parse_arguments():\n    parser = argparse.ArgumentParser(\n        description=\"Train a VITS TTS model for a specific character.\"\n    )\n    parser.add_argument(\n        \"--dataset_path\",\n        type=str,\n        required=True,",
        "detail": "voice_clone_train",
        "documentation": {}
    },
    {
        "label": "SpeechToText",
        "kind": 6,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "class SpeechToText:\n    \"\"\"\n    Handles Speech-to-Text (STT) with audio preprocessing and engine selection.\n    Includes noise reduction, normalization, and resampling for improved accuracy.\n    Supports engines: 'google', 'sphinx', 'whisper', 'vosk'.\n    \"\"\"\n    def __init__(\n        self,\n        use_microphone: bool = True,\n        audio_file: Optional[str] = None,",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "TextToSpeech",
        "kind": 6,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "class TextToSpeech:\n    \"\"\" Handles standard Text-to-Speech (TTS) using pyttsx3 or gTTS. \"\"\"\n    def __init__(\n        self,\n        use_pyttsx3: bool = True,\n        voice_name: Optional[str] = None,\n        speech_rate: int = 150,\n        lang: str = \"en\",\n    ) -> None:\n        self.use_pyttsx3 = use_pyttsx3",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "ClonedVoiceTTS",
        "kind": 6,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "class ClonedVoiceTTS:\n    \"\"\" Handles Text-to-Speech (TTS) using voice cloning models (e.g., XTTS). \"\"\"\n    def __init__(\n        self,\n        model_name: str = \"tts_models/multilingual/multi-dataset/xtts_v2\",\n        reference_wavs: Union[str, List[str]] = None,\n        use_gpu: bool = True,\n    ):\n        if CoquiTTS is None:\n            raise ImportError(\"TTS library is required for ClonedVoiceTTS but not found.\")",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "VoiceTrainer",
        "kind": 6,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "class VoiceTrainer:\n    \"\"\" Handles voice training dataset management and interaction with training scripts for specific characters. \"\"\"\n    def __init__(self, character_name: str, base_dataset_dir: str = BASE_DATASET_DIR, base_model_dir: str = BASE_MODEL_DIR):\n        \"\"\"\n        Initializes the VoiceTrainer for a specific character.\n        Args:\n            character_name: The name of the character (used for directory paths).\n            base_dataset_dir: The root directory containing all character datasets.\n            base_model_dir: The root directory containing all trained character models.\n        \"\"\"",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "play_audio_with_pydub",
        "kind": 2,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "def play_audio_with_pydub(file_path):\n    \"\"\"\n    Plays an audio file using pydub. Handles various formats.\n    Args:\n        file_path: Path to the audio file to play.\n    \"\"\"\n    try:\n        audio = AudioSegment.from_file(file_path)\n        print(f\"Attempting to play audio with pydub: {file_path}\")\n        play(audio)",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "play_audio_with_simpleaudio",
        "kind": 2,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "def play_audio_with_simpleaudio(file_path):\n    \"\"\"\n    Plays a WAV audio file using simpleaudio.\n    Args:\n        file_path: Path to the WAV audio file to play.\n    \"\"\"\n    try:\n        print(f\"Attempting to play audio with simpleaudio: {file_path}\")\n        if not file_path.lower().endswith(\".wav\"):\n             print(\"Simpleaudio fallback requires WAV format. Skipping playback.\")",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "play_audio",
        "kind": 2,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "def play_audio(file_path):\n    \"\"\"\n    Plays an audio file using pydub or simpleaudio as fallback (for WAV).\n    Args:\n        file_path: Path to the audio file to play.\n    \"\"\"\n    try:\n        play_audio_with_pydub(file_path)\n    except Exception as e:\n        print(f\"Pydub playback failed ({e}). Falling back to simpleaudio for WAV if applicable.\")",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "measure_execution_time",
        "kind": 2,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "def measure_execution_time(func):\n    \"\"\" Decorator to measure the execution time of a function. \"\"\"\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        logging.info(f\"Function '{func.__name__}' executed in: {end_time - start_time:.2f} seconds\")\n        return result\n    return wrapper\n# Function to use `scipy.io.wavfile.read` for reading WAV files",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "read_wav_file_scipy",
        "kind": 2,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "def read_wav_file_scipy(file_path):\n    \"\"\" Reads a WAV file using Scipy and returns the sample rate and data. \"\"\"\n    try:\n        sample_rate, data = read_wav(file_path)\n        logging.debug(f\"Read WAV file (SciPy): {file_path} (Sample Rate: {sample_rate}, Data Shape: {data.shape})\")\n        return sample_rate, data\n    except Exception as e:\n        logging.error(f\"Error reading WAV file with SciPy: {e}\")\n        return None, None\n# Example usage of AudioProcessor (if TTS is installed)",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "process_audio_sample_coqui",
        "kind": 2,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "def process_audio_sample_coqui(audio_file):\n    \"\"\" Processes an audio file using Coqui TTS AudioProcessor. \"\"\"\n    if AudioProcessor is None:\n        print(\"AudioProcessor not available (TTS library missing).\")\n        return None\n    try:\n        # Example config - adjust as needed for your TTS model\n        ap = AudioProcessor(sample_rate=22050, num_mels=80)\n        processed_audio = ap.load_wav(audio_file)\n        logging.info(\"Audio processing with Coqui AudioProcessor complete.\")",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "record_and_play_sd",
        "kind": 2,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "def record_and_play_sd(duration=5, sample_rate=44100, device_index=None):\n    \"\"\" Records audio and plays it back using sounddevice. \"\"\"\n    logging.info(f\"Recording audio (sounddevice) for {duration} seconds...\")\n    try:\n        audio_data = sd.rec(int(duration * sample_rate), samplerate=sample_rate, channels=1, device_index=device_index, dtype=\"int16\")\n        sd.wait()\n        logging.info(\"Finished recording. Playing back (sounddevice)...\")\n        sd.play(audio_data, samplerate=sample_rate)\n        sd.wait()\n        return audio_data",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "save_wave_file_scipy",
        "kind": 2,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "def save_wave_file_scipy(audio_data: np.ndarray, filename: str, sample_rate: int = 44100) -> None:\n    \"\"\" Saves audio data (numpy array) to WAV using scipy.io.wavfile. \"\"\"\n    if audio_data is None:\n        logging.error(\"No audio data provided to save.\")\n        return\n    logging.info(f\"Saving audio data (scipy) to WAV file: {filename}\")\n    try:\n        write_wav(filename, sample_rate, audio_data)\n        logging.info(\"WAV file saved successfully (scipy).\")\n    except Exception as e:",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "get_audio_device_list",
        "kind": 2,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "def get_audio_device_list():\n    \"\"\" Prints a list of available audio input/output devices using sounddevice. \"\"\"\n    print(\"\\n--- Available Audio Devices (Sounddevice) ---\")\n    try:\n        devices = sd.query_devices()\n        default_input_idx = sd.default.device[0]\n        default_output_idx = sd.default.device[1]\n        print(\"Input Devices:\")\n        found_input = False\n        for i, device in enumerate(devices):",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "BASE_DATASET_DIR",
        "kind": 5,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "BASE_DATASET_DIR = \"voice_datasets\" # Base directory for all character datasets\nBASE_MODEL_DIR = \"trained_models\"   # Base directory for all trained character models\nMETADATA_FILENAME = \"metadata.csv\"  # Standard metadata filename\n# --- Helper Functions ---\n# Function to play audio using pydub\ndef play_audio_with_pydub(file_path):\n    \"\"\"\n    Plays an audio file using pydub. Handles various formats.\n    Args:\n        file_path: Path to the audio file to play.",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "BASE_MODEL_DIR",
        "kind": 5,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "BASE_MODEL_DIR = \"trained_models\"   # Base directory for all trained character models\nMETADATA_FILENAME = \"metadata.csv\"  # Standard metadata filename\n# --- Helper Functions ---\n# Function to play audio using pydub\ndef play_audio_with_pydub(file_path):\n    \"\"\"\n    Plays an audio file using pydub. Handles various formats.\n    Args:\n        file_path: Path to the audio file to play.\n    \"\"\"",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "METADATA_FILENAME",
        "kind": 5,
        "importPath": "voice_tools",
        "description": "voice_tools",
        "peekOfCode": "METADATA_FILENAME = \"metadata.csv\"  # Standard metadata filename\n# --- Helper Functions ---\n# Function to play audio using pydub\ndef play_audio_with_pydub(file_path):\n    \"\"\"\n    Plays an audio file using pydub. Handles various formats.\n    Args:\n        file_path: Path to the audio file to play.\n    \"\"\"\n    try:",
        "detail": "voice_tools",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "voice_trainer_cli",
        "description": "voice_trainer_cli",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        description=\"Voice Trainer CLI Tool - Manages datasets and training for specific characters.\",\n        formatter_class=argparse.RawTextHelpFormatter,  # Preserve newline formatting in help\n    )\n    # --- Required Argument ---\n    parser.add_argument(\n        \"--character\",\n        type=str,\n        required=True,",
        "detail": "voice_trainer_cli",
        "documentation": {}
    }
]